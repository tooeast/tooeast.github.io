[{"title":"2018再见，2019你好","url":"/2018/12/2018%E5%86%8D%E8%A7%81%EF%BC%8C2019%E4%BD%A0%E5%A5%BD/","content":"一年又要结束了，又到了年终总结的时候。\n这一年是转变的一年，从学生转变成了一个社会人。从一月份结束实习，六月底毕业，然后七月入职直到现在。过完了最后半年的学生生活，开始了自己的打拼之路。从实习变成正式入职其实没有很大的差别，不一样的恐怕只有自己的内心。角色的转变会带来对过去的怀念，深刻的明白了那句话：学生时代是最无忧无虑的时代。接下来的自己加油！\n这一年是成长的一年，不但的学习才能成长。实习给自己带来了对于技术的进步渴望，不断的学习只为了提高自己。最后半年的学校生活也让自己收获了很多，离开校园就要成长。不管是主动或者被动的成长，都是驱使自己前进的动力！\n其实总结是很费劲的，这一年貌似除了毕业工作也没什么别的值得记忆的事情。就这些吧，2019年还是要继续学习充实自己，向大佬看齐！\n","tags":["感悟"]},{"title":"JS正则表达式学习一","url":"/2018/11/JS%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AD%A6%E4%B9%A0%E4%B8%80/","content":"\n读到了老姚的正则表达式文章，对于正则表达式有了一个新的学习。在正则这块很多时候自己都是现用现查，很多地方都是囫囵吞枣。阅读老姚的新著，重新学习JS的正则表达式。分几个部分写一下读后笔记吧。\n\n先贴一下老姚文章的地址。一七年的文章现在才看到，汗😓\n文章共分七个章节介绍正则，我们这里主要做一下总结。\n1. 首先，正则是匹配模式，要么匹配字符，要么匹配位置。日常使用到最多的就是字符的匹配，比如说手机号的校验，用户昵称的校验等，很少会用到位置的匹配。但是其实我们常用的^、$就是匹配位置的锚字符。关于具体的内容稍后在总结，重要的是这个宗旨要有。\n2. 常用的字符匹配模式正则表达式的强大就在于他的模糊匹配。文章把这块分成两个部分\n\n横向模糊匹配\n\n这个是指字符串长度的模糊，最常用的如&#123;m,n&#125;指连续出现最少m次，最多n次。比如常用的手机号匹配/^1\\d&#123;10&#125;$/，指以 1 开头，后面出现十个数字的字符串。这里的&#123;10&#125;是&#123;10,10&#125;的简写，意思是只能出现十次。\n\n纵向模糊匹配\n\n这部分是指某个字符可能是不确定的，比如[abc]指这个字符可以是 ‘a’、’b’ 或者 ‘c’。比如限制用户输入的内容只能是数字或者字母的时候，可以使用/^[0-9a-zA-Z]&#123;5,10&#125;$/。\n3. 字符组的简写和量词的简写\n字符组的简写\n\n这里我们把[abc]这种形式称为字符组，如/^[0-9a-zA-Z]&#123;5,10&#125;$/这样的是简写的形式，-表示范围。除此之外还有排除字符组，如[^abc]表示这个字符不能是 ‘a’、’b’ 或者 ‘c’。另外还有常见的简写形式。\n\n\\d就是[0-9]。表示是一位数字。记忆方式：其英文是digit（数字）。\\D就是[^0-9]。表示除数字外的任意字符。\\w就是[0-9a-zA-Z_]。表示数字、大小写字母和下划线。记忆方式：w是word的简写，也称单词字符。\\W是[^0-9a-zA-Z_]。非单词字符。\\s是[\\t\\v\\n\\r\\f]。表示空白符，包括空格、水平制表符、垂直制表符、换行符、回车符、换页符。记忆方式：s是space character的首字母。\\S是[^\\t\\v\\n\\r\\f]。 非空白符。.就是[^\\n\\r\\u2028\\u2029]。通配符，表示几乎任意字符。换行符、回车符、行分隔符和段分隔符除外。记忆方式：想想省略号…中的每个点，都可以理解成占位符，表示任何类似的东西。\n\n\n量词的简写\n\n&#123;m,&#125; 表示至少出现m次。&#123;m&#125; 等价于&#123;m,m&#125;，表示出现m次。? 等价于&#123;0,1&#125;，表示出现或者不出现。记忆方式：问号的意思表示，有吗？+ 等价于&#123;1,&#125;，表示出现至少一次。记忆方式：加号是追加的意思，得先有一个，然后才考虑追加。* 等价于&#123;0,&#125;，表示出现任意次，有可能不出现。记忆方式：看看天上的星星，可能一颗没有，可能零散有几颗，可能数也数不过来。\n4. 贪婪匹配和惰性匹配贪婪匹配是指，在匹配中如果出现量词区间，他就会尽可能多的去匹配，所以叫贪婪匹配。\n比如说 /\\d&#123;2,5&#125;/ ，可以匹配二到五次，他会尝试着匹配，知道不符合。这个会引发一个回溯的问题，等会儿会说。\n与贪婪匹配相对的是惰性匹配，意思是二到五次的话，够了两次就不接着匹配了。如 /\\d&#123;2,5&#125;?/ 。在后面加个问号就变成了惰性匹配。\n","tags":["正则表达式","笔记"]},{"title":"JS正则表达式学习三","url":"/2018/11/JS%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AD%A6%E4%B9%A0%E4%B8%89/","content":"继续上文，先贴原文地址。\n\n之前的部分学习了字符匹配和位置匹配，可以说涵盖了很多日常开发中会用到的知识点。接下来要学习的是我觉得正则中很神奇的一部分，那就是括号的使用\n\n就像文章中说的，对括号的使用是否得心应手，是衡量对正则的掌握水平的侧面标准。确实是，再正则中使用括号会有很好的效果，能起到很好的功能作用。\n常用的是它的分组功能，顾名思义就是将一组内容作为一个整体。比如 /(ab)+/g 就表示 ab 这个整体连续出现。如果不写括号会被认为是 b 的连续出现。除此之外还有分支功能，如 (x|y) 表示既可能是 x ，也可能是 y。这些都是比较常见的用法，接下来学习比较少见到，但是却能高效解决问题的用法。\n1. 引用分组这是很重要的一个功能，常常用来作为数据的提取以及替换的操作，将需要操作的部分用括号括起来之后，就可以提取或者替换。\n比如常见的日期提取，这里贴上原文中的一段代码：\nvar regex = /(\\d&#123;4&#125;)-(\\d&#123;2&#125;)-(\\d&#123;2&#125;)/;var string = &quot;2017-06-12&quot;;console.log( string.match(regex) ); // =&gt; [&quot;2017-06-12&quot;, &quot;2017&quot;, &quot;06&quot;, &quot;12&quot;, index: 0, input: &quot;2017-06-12&quot;]\n可以看到，使用 match() 方法可以将正则需要提取的内容拿出来。也可以使用 exec()：\nvar regex = /(\\d&#123;4&#125;)-(\\d&#123;2&#125;)-(\\d&#123;2&#125;)/;var string = &quot;2017-06-12&quot;;console.log( regex.exec(string) ); // =&gt; [&quot;2017-06-12&quot;, &quot;2017&quot;, &quot;06&quot;, &quot;12&quot;, index: 0, input: &quot;2017-06-12&quot;]\n\n除此之外还可以使用 $1  到$9 来获取，这是我觉得这块内容最有用的地方，接下来就会用到。\n除了匹配之外，替换才是更常用的，比如我们常见的日期替换，要把 2018-10-11 换成 2018/10/11。很多时候我们都是把 - 直接替换成 / ，但是如果要换成 10/11/2018 的时候，就不能在用这个办法，所以接下来的才是更好的方法。\nvar regex = /(\\d&#123;4&#125;)-(\\d&#123;2&#125;)-(\\d&#123;2&#125;)/;var string = &quot;2018-10-11&quot;;var result = string.replace(regex, &quot;$2/$3/$1&quot;);console.log(result); // =&gt; &quot;10/11/2018&quot;\n\n可以看到从左到右三个括号依次包括的是 年、月、日 。然后通过 $1、$2、$3 分别指代，然后我们可以排列成我们想要的形式了。\n2. 反向引用这在业务代码中几乎没有见到过，之前也完全没听说过正则还可以这样用，大开眼界！\n反向引用指的是可以在正则本身里面引用之前的分组，即前面出现了某个字符，后面可以通过反向引用来拿到这个字符，然后进行想要的操作。这里继续贴上原文中的代码例子（自己想不出例子来，😓）：\nvar regex = /\\d&#123;4&#125;(-|\\/|\\.)\\d&#123;2&#125;(-|\\/|\\.)\\d&#123;2&#125;/;var string1 = &quot;2017-06-12&quot;;var string2 = &quot;2017/06/12&quot;;var string3 = &quot;2017.06.12&quot;;var string4 = &quot;2016-06/12&quot;;console.log( regex.test(string1) ); // trueconsole.log( regex.test(string2) ); // trueconsole.log( regex.test(string3) ); // trueconsole.log( regex.test(string4) ); // true\n\n如上所示，想要匹配 2016-06-12、2017/06/12、2017.06.12 这三种形式的日期，我们可能会写出示例中的代码，可以看到确实是可以匹配的，但是最后一种情况 2016-06/12 也会被匹配。因为没法对前后出现的内容做同步，前面使用的是 - ，但是没办法保证后面使用的同样也是 -。反向引用可以解决这个问题：\nvar regex = /\\d&#123;4&#125;(-|\\/|\\.)\\d&#123;2&#125;\\1\\d&#123;2&#125;/;var string1 = &quot;2017-06-12&quot;;var string2 = &quot;2017/06/12&quot;;var string3 = &quot;2017.06.12&quot;;var string4 = &quot;2016-06/12&quot;;console.log( regex.test(string1) ); // trueconsole.log( regex.test(string2) ); // trueconsole.log( regex.test(string3) ); // trueconsole.log( regex.test(string4) ); // false\n\n可以看到，使用了 \\1 来引用之前括号中的内容，这样就会使得前后是一致的，所以 2016-06/12  这种情况是不能够通过的。\n有了 \\1 ，那么相应的 \\2 \\3 \\4 也就很好理解了，但是这种情况下会出现括号嵌套的情况，这种情况下以左括号出现的先后顺序为准，比如：\nvar regex = /^((\\d)(\\d(\\d)))\\1\\2\\3\\4$/;var string = &quot;1231231233&quot;;console.log( regex.test(string) ); // trueconsole.log( RegExp.$1 ); // 123console.log( RegExp.$2 ); // 1console.log( RegExp.$3 ); // 23console.log( RegExp.$4 ); // 3\n\n如果引用的分组不存在，那么 \\1 就是简单的对字符 1 做了转义。\n3. 非捕获分组之前的使用都是使用括号来匹配数据，但是如果不想要这些功能，只想安安静静的做一个普通的括号呢，也有办法。可以使用非捕获分组  (?:p) 。这样就不会被引用了！\n","tags":["正则表达式","笔记"]},{"title":"JS正则表达式学习二","url":"/2018/11/JS%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AD%A6%E4%B9%A0%E4%BA%8C/","content":"先贴一下老姚文章的地址。\n\n上次主要记录了字符匹配的部分，接下来学习位置匹配的部分\n\n1. 位置是什么，如何匹配位置其实很好理解，就是相邻的字符之间的位置。比如常见的最开头和最结尾。在 es5 中共有六个锚字符，也就是表示位置的字符：^ $ \\b \\B (?=p) (?!p)。其中^和$在多行匹配时，表示每行的开头和结尾。\n&#96;&#96;&#96;(?&#x3D;p)&#96;&#96;&#96;表示 &#96;&#96;&#96;p&#96;&#96;&#96;前面的位置。相对的，&#96;&#96;&#96;(?!p)&#96;&#96;&#96;表示非&#96;&#96;&#96;p&#96;&#96;&#96;前面的位置。比如说如下：&#96;&#96;&#96;javascriptvar result &#x3D; &quot;hello&quot;.replace(&#x2F;(?&#x3D;l)&#x2F;g, &#39;#&#39;);console.log(result); &#x2F;&#x2F; &#x3D;&gt; &quot;he#l#lo&quot;var result &#x3D; &quot;hello&quot;.replace(&#x2F;(?!l)&#x2F;g, &#39;#&#39;);console.log(result); &#x2F;&#x2F; &#x3D;&gt; &quot;#h#ell#o#&quot;\n\n2. 例子\n数字千分位分隔符\n\n实际开发中，经常会有需要添加数字千分位的需求。例如12345678 变成 12,345,678。代码如下：\nvar result = &quot;12345678&quot;.replace(/(?!^)(?=(\\d&#123;3&#125;)+$)/g, &#x27;,&#x27;)console.log(result); // =&gt; &quot;12,345,678&quot;\n\n这个正则表示，至少出现一次三个数字连续出现的时候，则在三个数字前面的位置添加一个逗号。最前面的(?!^)表示这个位置不能是开头，否则会出现 ,123,456,789 的情况。\n\n密码校验问题\n\n我们都知道，用户输入密码的时候是很有必要做检验的。很多平台就会规定密码必须包含数字大小写字母特殊符等，而且有长度限制。\n比如光考虑长度和组成问题的话，会有 /^[0-9A-Za-z]&#123;6,12&#125;$/。这很明显，表示包含数字或者大小写字母的6到12位的字符串。但是这种情况不能判断是否包含某种元素，如不能判定是否包含数字，所以又了接下来的升级版。\n&#96;&#96;&#96;&#x2F;(?&#x3D;.*[0-9])(?&#x3D;.*[a-z])^[0-9A-Za-z]&#123;6,12&#125;$&#x2F;&#96;&#96;&#96;。这样就表示必须同时包含数字和小写字母。做了两次位置的校验。接下来是终极的答案。&#96;&#96;&#96;javascriptvar reg &#x3D; &#x2F;((?&#x3D;.*[0-9])(?&#x3D;.*[a-z])|(?&#x3D;.*[0-9])(?&#x3D;.*[A-Z])|(?&#x3D;.*[a-z])(?&#x3D;.*[A-Z]))^[0-9A-Za-z]&#123;6,12&#125;$&#x2F;;console.log( reg.test(&quot;1234567&quot;) ); &#x2F;&#x2F; false 全是数字console.log( reg.test(&quot;abcdef&quot;) ); &#x2F;&#x2F; false 全是小写字母console.log( reg.test(&quot;ABCDEFGH&quot;) ); &#x2F;&#x2F; false 全是大写字母console.log( reg.test(&quot;ab23C&quot;) ); &#x2F;&#x2F; false 不足6位console.log( reg.test(&quot;ABCDEF234&quot;) ); &#x2F;&#x2F; true 大写字母和数字console.log( reg.test(&quot;abcdEF234&quot;) ); &#x2F;&#x2F; true 三者都有\n以上表示这个密码必须符合下列三种情况之一：同时包含数字和小写字母、同时包含数字和大写字母、同时包含小写字母和大写字母。符合任意一种就会通过。对于这种情况下，我们也可以使用(?!p)。因为要求三种字符（数字、小写字母、大写字母）至少出现两种，则意味着不能光有一种字符，所以还有如下写法。\nvar reg = /(?!^[0-9]&#123;6,12&#125;$)(?!^[a-z]&#123;6,12&#125;$)(?!^[A-Z]&#123;6,12&#125;$)^[0-9A-Za-z]&#123;6,12&#125;$/;console.log( reg.test(&quot;1234567&quot;) ); // false 全是数字console.log( reg.test(&quot;abcdef&quot;) ); // false 全是小写字母console.log( reg.test(&quot;ABCDEFGH&quot;) ); // false 全是大写字母console.log( reg.test(&quot;ab23C&quot;) ); // false 不足6位console.log( reg.test(&quot;ABCDEF234&quot;) ); // true 大写字母和数字console.log( reg.test(&quot;abcdEF234&quot;) ); // true 三者都有\n\n其中 (?!^[0-9]&#123;6,12&#125;$) 表示不能全是数字，其他同理。\n\n学习到这里其实脑袋是有点懵的，关于位置的匹配本来使用的就不多。幸亏看到了这篇干货文章，好好学习了！\n\n","tags":["正则表达式","笔记"]},{"title":"JS正则表达式学习四","url":"/2018/11/JS%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AD%A6%E4%B9%A0%E5%9B%9B/","content":"惯例，先上原文。\n\n之前我们学习了正则的字符匹配、位置匹配和括号的使用。接下来我们学习正则表达式中常见的一个问题：回溯问题。如果说前面是学习正则的使用，那么本节感觉是学习正则的优化。我觉得回溯其实是一种性能的浪费，所以学习写好的正则可以减少回溯的产生，提高效率。\n\n回溯，顾名思义就是回复过去状态，可以理解为回退。老姚文章中说这是匹配原理中的一个名词，但其实实际使用很少有人会关心这个问题，甚至都没有听过这种说法。所以接下来我们学习高大上的回溯问题。\n1. 回溯的理解\n正则表达式匹配字符串的这种方式，有个学名，叫回溯法。回溯法也称试探法，它的基本思想是：从问题的某一种状态（初始状态）出发，搜索从这种状态出发所能达到的所有“状态”，当一条路走到“尽头”的时候（不能再前进），再后退一步或若干步，从另一种可能“状态”出发，继续搜索，直到所有的“路径”（状态）都试探过。这种不断“前进”、不断“回溯”寻找解的方法，就称作“回溯法”。（copy于百度百科）。本质上就是深度优先搜索算法。其中退到之前的某一步这一过程，我们称为“回溯”。从上面的描述过程中，可以看出，路走不通时，就会发生“回溯”。即，尝试匹配失败时，接下来的一步通常就是回溯。\n\n以上是原文中的解释，组织不了更好的语言索性直接贴过来了。\n2. 回溯的例子为了精简的总结，直接再贴个原文中的图过来。图表示的是用正则  /ab&#123;1,3&#125;bbc/ 匹配字符串 abbbc 的过程：\n\n从图上可以很清晰的看出来是因为贪婪量词 b&#123;1,3&#125; 的原因导致的回溯。但其实不只是贪婪量词可以导致回溯，不贪婪的惰性量词也会导致回溯，如下是使用 /^\\d&#123;1,3&#125;?\\d&#123;1,3&#125;$/ 匹配 12345  的过程：\n\n可以看到因为惰性量词一开始就很“满足”了，所以导致整体的匹配必须重来，所以哪怕是满足了也必须多拿点，这样为了整体才能成功！\n除了这两种情况，分支结构也可以导致回溯的发生，以下是使用 /can|candy/ 匹配字符串 candy 的过程：\n\n可以看到由于先满足了 can 所以就尝试着匹配之后的内容，但整体进行不下去了，所以必须回溯去匹配 candy 才能满足条件。\n\nJS的正则引擎是NFA，NFA是“非确定型有限自动机”的简写。大部分语言中的正则都是NFA，除此之外还有DFA引擎。（知识点，哈哈，单列）。\n\n至此，学习正则表达式的过程就告一段落了，其实老姚的文章后面还有内容，但是作为学习笔记总结，我觉得到这里就ok了，后面的内容有兴趣的童鞋可以去老姚的原文看哦  https://juejin.im/post/5965943ff265da6c30653879\n","tags":["正则表达式","笔记"]},{"title":"不要将函数当作回调使用","url":"/2021/05/no-function-callback/","content":"\n原作者：Jake Archibald\n原文链接：https://jakearchibald.com/2021/function-callback-risks/\n译者：当我是树吧、塔萨达尔\n\n这似乎是一个正在卷土重来的旧模式：\n// 把数字转化成千分位分隔的字符串。import &#123; toReadableNumber &#125; from &#x27;some-library&#x27;;const readableNumbers = someNumbers.map(toReadableNumber);\n\n的实现是这样的：&#96;&#96;&#96;javascriptexport function toReadableNumber(num) &#123;  &#x2F;&#x2F; 把数字转化成千分位分隔的字符串。  &#x2F;&#x2F; 例如 10000000 转化成 &#39;10,000,000&#39;&#125;\n\n这样看起来一切正常，但是如果some-library做了升级，结果可能就不一样了。因为toReadableNumber一开始可能就不是被设计用来作为array.map的参数的。\n问题出在这里：\n// 我们这样写:const readableNumbers = someNumbers.map(toReadableNumber);// 我们以为的效果:const readableNumbers = someNumbers.map((n) =&gt; toReadableNumber(n));// 实际的效果:const readableNumbers = someNumbers.map((item, index, arr) =&gt;  toReadableNumber(item, index, arr),);\n\n可以看到，除了item参数，还多余的传递了索引和数组本身给toReadableNumber。当toReadableNumber只有一个参数的时候这没什么问题，但是当发生如下修改时：\nexport function toReadableNumber(num, base = 10) &#123;  // 把数字转化成千分位分隔的字符串。  // 传入一个参数 base，默认值是 10&#125;\n\n开发人员已经尽力适配了老代码。虽然为toReadableNumber增加了一个参数，但是指定了默认值，这样做本身是没有任何问题的。但谁曾想在某些代码中toReadableNumber已经被传了三个参数！\n以上，由于toReadableNumber不是专门设计作为array.map的回调，所以更安全靠谱的做法是写一个适用的函数，然后单独调用toReadableNumber：\nconst readableNumbers = someNumbers.map((n) =&gt; toReadableNumber(n));\n\n这样做的好处是当toReadableNumber再增加参数，也不会造成代码错误。\nWeb 平台提供的函数也会有相同的问题最近看到这样一段代码：\n// A promise for the next frame:const nextFrame = () =&gt; new Promise(requestAnimationFrame);\n\n等效于：\nconst nextFrame = () =&gt;  new Promise((resolve, reject) =&gt; requestAnimationFrame(resolve, reject));\n\n之所以现在没有问题，是因为requestAnimationFrame只接受一个参数。如果将来requestAnimationFrame增加了额外的参数，所有进行了这项升级的浏览器在运行上述代码的时候都可能崩溃。\n这个例子很好地反应了这种模式是如何出错的：\nconst parsedInts = [&#x27;-10&#x27;, &#x27;0&#x27;, &#x27;10&#x27;, &#x27;20&#x27;, &#x27;30&#x27;].map(parseInt);\n\n如果面试中遇到这样的问题，建议你翻翻白眼直接离场。但我还是说一下吧，答案是[-10, NaN, 2, 6, 12]，因为 parseInt 有第二个参数。\n对象参数也有相同的问题Chrome 90 将允许你使用一个AbortSignal来删除一个事件监听器，这意味着一个单独的AbortSignal可以用来删除事件监听器、取消请求、以及做其他任何支持信号的事情。\nconst controller = new AbortController();const &#123; signal &#125; = controller;el.addEventListener(&#x27;mousemove&#x27;, callback, &#123; signal &#125;);el.addEventListener(&#x27;pointermove&#x27;, callback, &#123; signal &#125;);el.addEventListener(&#x27;touchmove&#x27;, callback, &#123; signal &#125;);// 移除所有监听controller.abort();\n\n我们期望的写法是这样的：\nconst controller = new AbortController();const &#123; signal &#125; = controller;el.addEventListener(name, callback, &#123; signal &#125;);\n\n但是有人这样写：\nconst controller = new AbortController();el.addEventListener(name, callback, controller);\n\n和前面的例子一样，现在这样写没问题，不代表以后不会出问题。\n[AbortController](https://dom.spec.whatwg.org/#abortcontroller) 和 [addEventListener](https://link.zhihu.com/?target如果说将来&#96;AbortController&#96;增加一个&#96;controller.capture(otherController)&#96;方法，那么结果就会失控，你的监听器的行为就改变了。因为 &#96;addEventListener&#96; 会把 &#96;capture&#96; 视为一个真值，&#96;capture&#96; 对 &#96;addEventListener&#96; 来说是一个有效的选项（译者注：&#96;addEventListener&#96;的第三个参数&#96;options&#96;是一个对象，包含一个名为&#96;capture&#96;的布尔值字段）。正如那个回调的例子，最好创建一个对象专门来做 &#96;addEventListener&#96; 的第三个参数&#96;options&#96;。&#96;&#96;&#96;jsconst controller &#x3D; new AbortController();const options &#x3D; &#123; signal: controller.signal &#125;;el.addEventListener(name, callback, options);&#x2F;&#x2F; 或者这样const &#123; signal &#125; &#x3D; controller;el.addEventListener(name, callback, &#123; signal &#125;);\n\n综上所述，小心作为回调使用的函数，以及作为选项使用的对象，除非它们就是专为此设计的。我不知道有哪一条 linting 规则可以捕捉到它。（注：好像这个规则可以捕获一些情况，感谢 James Ross !）\nTypeScript 并不能解决这个问题\n注：当我第一次发布文章的时候，我就说了 TypeScript 不能防止这些问题，但是还是有些人在 Twitter 上告诉我说，”用 TypeScript 就行了“，所以我们就好好唠唠这个事情。\n\nTypeScript 这样写会报错：\nfunction oneArg(arg1: string) &#123;  console.log(arg1);&#125;oneArg(&#x27;hello&#x27;, &#x27;world&#x27;);//              ^^^^^^^// Expected 1 arguments, but got 2.\n\n但是这么写就不报错：\nfunction twoArgCallback(cb: (arg1: string, arg2: string) =&gt; void) &#123;  cb(&#x27;hello&#x27;, &#x27;world&#x27;);&#125;twoArgCallback(oneArg);\n\n。。。虽然结果是一样的（译者注：都是 oneArg 方法接收了两个参数）。\n因此 TypeScript 这么写也不报错：\nfunction toReadableNumber(num: number): string &#123;  // 把数字转化成千分位分隔的字符串。  // 例如 10000000 转化成 &#x27;10,000,000&#x27;  return &#x27;&#x27;;&#125;const readableNumbers = [1, 2, 3].map(toReadableNumber);\n\n如果 toReadableNumber 添加一个 string 类型的参数，TypeScript 会报错，但是这个检查对我们这个例子来说没有用。我们新增的参数类型是 _number_， 它符合类型约束。\n对于requestAnimationFrame来说情况会更加糟糕，只要使用新版本浏览器的时候就会出错，和项目版本无关。此外，TypeScript DOM 类型往往落后于浏览器几个月。\n尽管我是 TypeScript 的粉丝，此博客是使用 TypeScript 构建的，但它不能解决此问题，而且可能不应该解决。\n从这一点来说，大部分其他类型语言表现得和 TypeScript 都不相同，并且不允许以这种方式进行回调。但是 TypeScript 是有意为之，否则下面的代码将无法运行，因为被传入的回调函数被传入了多余的参数。\nconst numbers = [1, 2, 3];const doubledNumbers = numbers.map((n) =&gt; n * 2);\n\n在 JavaScript 中这是非常常见的做法，并且非常安全。所以 TypeScript 这样做也是情理之中。\n问题是“这个函数是不是用来做 map 的回调的”，对于 JavaScript 来说，类型并不能真正解决问题。相反，我好奇 JS 是不是应该在传入多余参数的时候抛出错误，确实，这将’保留’额外的参数位置以便之后的升级。但在现有功能上直接改造是不现实的，这样会造成兼容性的问题，但是我们可以现在增加控制台的警告。我提出过这样的想法，但是并没有多少人感兴趣。\n另外当涉及选项对象时，事情会变得有些棘手：\ninterface Options &#123;  reverse?: boolean;&#125;function whatever(&#123; reverse = false &#125;: Options = &#123;&#125;) &#123;  console.log(reverse);&#125;\n\n按照上面的说法，如果传递给whatever的对象具有reverse之外的属性，则 API 应该发出警告。我们看下面的示例：\nwhatever(&#123; reverse: true &#125;);\n\n我们传入的是一个 Object 的实例，它天然就有额外的属性，像toString，constructor，valueOf，hasOwnProperty等。所以要求属性都是“自有”属性（这不是它在运行时的工作方式）似乎过于严格，所以对于 Object自身的属性或许应该考虑放宽一些限制。\n","tags":["笔记","JS"]},{"title":"一个前端的基础正则修养","url":"/2020/12/%E4%B8%80%E4%B8%AA%E5%89%8D%E7%AB%AF%E7%9A%84%E5%9F%BA%E7%A1%80%E6%AD%A3%E5%88%99%E4%BF%AE%E5%85%BB/","content":"一名前端的基础正则修养概念\n什么是正则？\n\n正则表达式，又称规则表达式。（英语：Regular Expression，在代码中常简写为regex、regexp或RE），计算机科学的一个概念。正则表达式通常被用来检索、替换那些符合某个模式(规则)的文本。\n\n详解\n\n\n正则有几种？JS 中的正则是哪种？\n\n正则引擎主要可以分为基本不同的两大类：\n\nDFA (Deterministic finite automaton) 确定型有穷自动机\nNFA (Non-deterministic finite automaton) 非确定型有穷自动机\n\nJS 使用的是 NFA。\n\n具体分析\n\n题目\n校验手机号\n\n手机号码的校验。一般没有特殊需求，只校验开头是1的11位数字\nlet call &#x3D; &#39;16601167965&#39;;console.log(&#x2F;^1\\d&#123;10&#125;$&#x2F;.test(call)); &#x2F;&#x2F; true\n\n\n校验身份证号码\n\n身份证号码可能为15位或18位，15位为全数字，18位中前17位为数字，最后一位为数字或者X\n\n日期的提取\n\n将一串字符串形式的日期转化成特定的日期格式，通过正则的提取，提取到需要的信息\n字符的匹配\n横向模糊匹配\n纵向模糊匹配\n多选分支\n字符组的简写\n量词的简写\n贪婪匹配和惰性匹配\n\n位置的匹配\n位置的概念，什么是位置？\n做题\n数字千分符问题\n货币格式化问题\n密码校验问题\n\n\n\n括号的妙用1. 分组表示一个整体\nlet string &#x3D; &quot;ababa abbb ababab&quot;;let reg1 &#x3D; &#x2F;(ab)+&#x2F;g;console.log( string.match(reg1) ); &#x2F;&#x2F; &#x3D;&gt; [&quot;abab&quot;, &quot;ab&quot;, &quot;ababab&quot;]let reg2 &#x3D; &#x2F;ab+&#x2F;g;console.log( string.match(reg2) ); &#x2F;&#x2F; &#x3D;&gt; [&quot;ab&quot;, &quot;ab&quot;, &quot;abbb&quot;, &quot;ab&quot;, &quot;ab&quot;, &quot;ab&quot;]\n\n2. 分支结构let reg &#x3D; &#x2F;^Hello (World|changba)$&#x2F;;console.log( reg.test(&quot;Hello World&quot;) );&#x2F;&#x2F; &#x3D;&gt; trueconsole.log( reg.test(&quot;Hello changba&quot;) );&#x2F;&#x2F; &#x3D;&gt; true\n\n3. 引用分组这是很重要的一个功能，常常用来作为数据的提取以及替换的操作，将需要操作的部分用括号括起来之后，就可以提取或者替换。\n\n一个常见的日期的提取功能let string &#x3D; &quot;2020-12-11&quot;;let regex1 &#x3D; &#x2F;\\d&#123;4&#125;-\\d&#123;2&#125;-\\d&#123;2&#125;&#x2F;;let regex2 &#x3D; &#x2F;(\\d&#123;4&#125;)-(\\d&#123;2&#125;)-(\\d&#123;2&#125;)&#x2F;;console.log( string.match(regex1) ); &#x2F;&#x2F; &#x3D;&gt; [&quot;2020-12-11&quot;, index: 0, input: &quot;2020-12-11&quot;, groups: undefined]console.log( string.match(regex2) ); &#x2F;&#x2F; &#x3D;&gt; [&quot;2020-12-11&quot;, &quot;2020&quot;, &quot;12&quot;, &quot;11&quot;, index: 0, input: &quot;2020-12-11&quot;, groups: undefined]console.log( reg1.exec(string) );&#x2F;&#x2F; &#x3D;&gt; [&quot;2020-12-11&quot;, index: 0, input: &quot;2020-12-11&quot;, groups: undefined]console.log( reg2.exec(string) );&#x2F;&#x2F; &#x3D;&gt; [&quot;2020-12-11&quot;, &quot;2020&quot;, &quot;12&quot;, &quot;11&quot;, index: 0, input: &quot;2020-12-11&quot;, groups: undefined]\n\n括号的嵌套怎么搞？结果是什么let string &#x3D; &#39;2020-12-11&#39;;let reg &#x3D; &#x2F;((\\d&#123;4&#125;)-(\\d&#123;2&#125;))-(\\d&#123;2&#125;)&#x2F;;console.log( string.match(reg) );&#x2F;&#x2F; &#x3D;&gt; [&quot;2020-12-11&quot;, &quot;2020-12&quot;, &quot;2020&quot;, &quot;12&quot;, &quot;11&quot;, index: 0, input: &quot;2020-12-11&quot;, groups: undefined]\n\n依据左括号 ( 出现的顺序。\n额外小问题match 和 exec 的区别？\n\nexec是RegExp类的方法，match是String类的方法\nexec 只会匹配第一个符合的字符串（意味着g对其不起作用），跟所有分组的反向引用。match 是否返回所有匹配的数组跟正则表达式里是否带着g有关系\n\nlet str &#x3D; &#39;hello world, hello beijing!&#39;;let reg1 &#x3D; &#x2F;hello&#x2F;;let reg2 &#x3D; &#x2F;hello&#x2F;g;console.log( str.match(reg1) );&#x2F;&#x2F; &#x3D;&gt; [&quot;hello&quot;, index: 0, input: &quot;hello world, hello beijing!&quot;, groups: undefined]console.log( reg1.exec(str) );&#x2F;&#x2F; &#x3D;&gt; [&quot;hello&quot;, index: 0, input: &quot;hello world, hello beijing!&quot;, groups: undefined]console.log( str.match(reg2) );&#x2F;&#x2F; &#x3D;&gt; [&quot;hello&quot;, &quot;hello&quot;]console.log( reg2.exec(str) );&#x2F;&#x2F; &#x3D;&gt; [&quot;hello&quot;, index: 0, input: &quot;hello world, hello beijing!&quot;, groups: undefined]\n\n再一个额外小问题match 方法的返回值，为什么有的时候有 input 和 index ，有的时候没有？\n和是否是全局匹配有关系，全局匹配时没有。\n最后一个额外小知识match 返回值字段含义\nconsole.log( string.match(regex2) ); &#x2F;&#x2F; &#x3D;&gt; [&quot;2020-12-11&quot;, &quot;2020&quot;, &quot;12&quot;, &quot;11&quot;, index: 0, input: &quot;2020-12-11&quot;, groups: undefined]\n\n\nmatch方法在有匹配结果的时候返回值是一个数组。\n数组第一个元素是match方法首次匹配到的子字符串，如果有引用分组，则接下来是引用分组的匹配内容\nindex属性值返回首次匹配到子字符串的位置。\ninput属性值是原字符串。\ngroups属性当前并不被支持，暂时不做介绍。\n\n没匹配到则只返回 null\n其他当使用引用分组，且匹配成功，可以使用构造函数的全局属性 $1 至 $9 来获取\nlet string &#x3D; &quot;2020-12-11&quot;;let regex &#x3D; &#x2F;(\\d&#123;4&#125;)-(\\d&#123;2&#125;)-(\\d&#123;2&#125;)&#x2F;;regex.exec(string); &#x2F;&#x2F; 这里用什么方式都行，只要执行了正则匹配&#x2F;&#x2F; regex.test(string)&#x2F;&#x2F; string.match(regex)console.log( RegExp.$1 );&#x2F;&#x2F; &#x3D;&gt; &quot;2020&quot;console.log( RegExp.$2 );&#x2F;&#x2F; &#x3D;&gt; &quot;12&quot;console.log( RegExp.$3 );&#x2F;&#x2F; &#x3D;&gt; &quot;11&quot;console.log( RegExp.$4 );&#x2F;&#x2F; &#x3D;&gt; &quot;&quot;console.log( RegExp.$0 );&#x2F;&#x2F; &#x3D;&gt; undefined\n当括号超过十个呢？let reg &#x3D; &#x2F;(\\d(\\d(\\d(\\d(\\d(\\d(\\d(\\d(\\d(\\d\\d(\\d)))))))))))&#x2F;;let str &#x3D; &#39;12345678901&#39;;console.log( str.match(reg) );&#x2F;&#x2F; &#x3D;&gt; [&quot;12345678901&quot;, &quot;12345678901&quot;, &quot;2345678901&quot;, &quot;345678901&quot;, &quot;45678901&quot;, &quot;5678901&quot;, &quot;678901&quot;, &quot;78901&quot;, &quot;8901&quot;, &quot;901&quot;, &quot;01&quot;, &quot;1&quot;, index: 0, input: &quot;12345678901&quot;, groups: undefined]console.log( str.replace(reg, &#39;$9--$10--$11&#39;) );&#x2F;&#x2F; &#x3D;&gt; &quot;901--01--1&quot;console.log( RegExp.$9 );&#x2F;&#x2F; &#x3D;&gt; &quot;901&quot;console.log( RegExp.$10 );&#x2F;&#x2F; &#x3D;&gt; undefined\n\n\n4. 反向引用需求传入一个日期，要求验证其满足一下形式之一。2020-12-11、2020.12.11、2020/12/11。\nvar regex &#x3D; &#x2F;\\d&#123;4&#125;(-|\\&#x2F;|\\.)\\d&#123;2&#125;(-|\\&#x2F;|\\.)\\d&#123;2&#125;&#x2F;;var string1 &#x3D; &quot;2020-12-11&quot;;var string2 &#x3D; &quot;2020&#x2F;12&#x2F;11&quot;;var string3 &#x3D; &quot;2020.12.11&quot;;console.log( regex.test(string1) ); &#x2F;&#x2F; trueconsole.log( regex.test(string2) ); &#x2F;&#x2F; trueconsole.log( regex.test(string3) ); &#x2F;&#x2F; true\n\n上述代码看似满足了需求，但是会出现以下情况：\nvar string4 &#x3D; &quot;2020-12&#x2F;11&quot;;console.log( regex.test(string4) ); &#x2F;&#x2F; truevar string5 &#x3D; &quot;2020.12-11&quot;;console.log( regex.test(string5) ); &#x2F;&#x2F; true\n\n怎么解决？\nvar regex &#x3D; &#x2F;\\d&#123;4&#125;(-|\\&#x2F;|\\.)\\d&#123;2&#125;\\1\\d&#123;2&#125;&#x2F;;var string1 &#x3D; &quot;2020-12-11&quot;;var string2 &#x3D; &quot;2020&#x2F;12&#x2F;11&quot;;var string3 &#x3D; &quot;2020.12.11&quot;;var string4 &#x3D; &quot;2020-12&#x2F;11&quot;;var string4 &#x3D; &quot;2020.12-11&quot;;console.log( regex.test(string1) ); &#x2F;&#x2F; trueconsole.log( regex.test(string2) ); &#x2F;&#x2F; trueconsole.log( regex.test(string3) ); &#x2F;&#x2F; trueconsole.log( regex.test(string4) ); &#x2F;&#x2F; falseconsole.log( regex.test(string5) ); &#x2F;&#x2F; false\n\n可以看到上述正则中 \\1 是对前面括号内容的引用。实现了前后统一。反向引用指的是可以在正则本身里面引用之前的分组，即前面出现了某个字符，后面可以通过反向引用来拿到这个字符，然后进行想要的操作，如果引用的分组不存在，那么 \\1 就是简单的对字符 1 做了转义。。\n一个提问\n请给出一个符合下面正则要求的字符串\nvar regex &#x3D; &#x2F;^((\\d)(\\d))\\1\\2\\3$&#x2F;;console.log( regex.test(&#39;121212&#39;) );&#x2F;&#x2F; &#x3D;&gt; true\n\n这个呢？\nvar regex &#x3D; &#x2F;^((\\d)(\\d(\\d)))\\1\\2\\3\\4$&#x2F;;console.log( regex.test(&#39;1231231233&#39;) );&#x2F;&#x2F; &#x3D;&gt; true\n\n5. 命名分组前面讲捕获分组都是通过位置编号来访问，还支持对捕获分组命名。这样就比较容易理解。\nlet string &#x3D; &#39;2020-12-11&#39;;let reg &#x3D; &#x2F;((?&lt;year&gt;\\d&#123;4&#125;)-(?&lt;month&gt;\\d&#123;2&#125;))-(?&lt;day&gt;\\d&#123;2&#125;)&#x2F;string.match(reg);(5) [&quot;2020-12-11&quot;, &quot;2020-12&quot;, &quot;2020&quot;, &quot;12&quot;, &quot;11&quot;, index: 0, input: &quot;2020-12-11&quot;, groups: &#123;…&#125;]    0: &quot;2020-12-11&quot;    1: &quot;2020-12&quot;    2: &quot;2020&quot;    3: &quot;12&quot;    4: &quot;11&quot;    groups:        day: &quot;11&quot;        month: &quot;12&quot;        year: &quot;2020&quot;    index: 0    input: &quot;2020-12-11&quot;    length: 5    __proto__: Array(0)\n\n命字分组的反向引用let reg &#x3D; &#x2F;(?&lt;year&gt;\\d&#123;4&#125;)-(?&lt;month&gt;\\d&#123;2&#125;--\\k&lt;year&gt;)&#x2F;;console.log( reg.test(&#39;2020-12--2020&#39;) );&#x2F;&#x2F; &#x3D;&gt; true\n\n6. 非捕获分组之前文中出现的分组，都会捕获它们匹配到的数据，以便后续引用，因此也称他们是捕获型分组。\n而非捕获分组顾名思义，与捕获分组相反，就是不会将分组匹配的内容放在内存中。主要是为了提高性能。使用方法：在分组的开头加上?:\nlet string &#x3D; &#39;2020-12-11&#39;;let reg1 &#x3D; &#x2F;(\\d&#123;4&#125;)-(\\d&#123;2&#125;)-(\\d&#123;2&#125;)&#x2F;;let reg2 &#x3D; &#x2F;(\\d&#123;4&#125;)-(\\d&#123;2&#125;)-(?:\\d&#123;2&#125;)&#x2F;;console.log( string.match(reg1) );&#x2F;&#x2F; &#x3D;&gt; [&quot;2020-12-11&quot;, &quot;2020&quot;, &quot;12&quot;, &quot;11&quot;, index: 0, input: &quot;2020-12-11&quot;, groups: undefined]console.log( string.match(reg2) );&#x2F;&#x2F; &#x3D;&gt; [&quot;2020-12-11&quot;, &quot;2020&quot;, &quot;12&quot;, index: 0, input: &quot;2020-12-11&quot;, groups: undefined]\n\n7. 常见的正则方法\ntrim\n\nlet trim &#x3D; str &#x3D;&gt; str.replace(&#x2F;^\\s+|\\s+$&#x2F;g, &#39;&#39;);let str &#x3D; &#39;  123  &#39;;console.log( trim(str) );&#x2F;&#x2F; &#x3D;&gt; &quot;123&quot;\n\n\n句子里单词首字母大写\n\nlet func &#x3D; str &#x3D;&gt; str.toLowerCase().replace(&#x2F;(?:^|\\s)\\w&#x2F;g, word &#x3D;&gt; word.toUpperCase());let str &#x3D; &#39;hello world, i am liuzedong&#39;;console.log( func(str) );&#x2F;&#x2F; &#x3D;&gt; &quot;Hello World, I Am Liuzedong&quot;","tags":["正则表达式","前端修养","分享会"]},{"title":"使用promise控制并发数量","url":"/2018/08/%E4%BD%BF%E7%94%A8promise%E6%8E%A7%E5%88%B6%E5%B9%B6%E5%8F%91%E6%95%B0%E9%87%8F/","content":"不记得什么时候在什么地方看到的这段代码，当时觉得很神奇，promise 还可以这么用。\n这里使用 promise 来控制并发数量，在实际中可以放在图片加载或者资源加在的时候，以防占用大量带宽影响其他资源的加载，我认为还是有很大的实际作用的。\n代码如下：\n// 模拟任务，设置任务的时间var urls = [  &#123; info: &#x27;link1&#x27;, time: 3000 &#125;,  &#123; info: &#x27;link2&#x27;, time: 2000 &#125;,  &#123; info: &#x27;link3&#x27;, time: 5000 &#125;,  &#123; info: &#x27;link4&#x27;, time: 1000 &#125;,  &#123; info: &#x27;link5&#x27;, time: 1200 &#125;,  &#123; info: &#x27;link6&#x27;, time: 2000 &#125;,  &#123; info: &#x27;link7&#x27;, time: 800 &#125;,  &#123; info: &#x27;link8&#x27;, time: 3000 &#125;,];// 设置我们要执行的任务function loadImg(url) &#123;    return new Promise((resolve, reject) =&gt; &#123;      console.log(&quot;----&quot; + url.info + &quot; start!&quot;);      setTimeout(() =&gt; &#123;        console.log( url.info + &quot; OK!!!&quot;);        resolve();      &#125;, url.time)    &#125;)&#125;;/*  @ 主函数  tasks: 任务列表  func: 任务的方法，执行函数  limit: 最大并发数*/function multiTask(tasks, func, limit) &#123;  // 先将任务列表拷贝一份，接下来要操作  let squ = [].concat(tasks);  // 初始化并发池  let promises = [];  // 直接将任务按照并发最大值 放入列表中（还未开始执行）  promises = squ.splice(0, limit).map((task, index) =&gt; &#123;    return func(task).then(() =&gt; &#123;      return index    &#125;)  &#125;)  // 这里利用 reduce 来实现并发池的维护  return squ.reduce((res, task) =&gt; &#123;    // 这里用到 .then 是因为给 reduce 的初始值是 Promise.resolve()    return res.then(() =&gt; &#123;      // Promise.race 返回第一个执行完毕的任务 的位置      return Promise.race(promises);    &#125;).then((num) =&gt; &#123;      // 处理执行完成的任务，并且将新的任务替代 放入并发池，并且开始执行新的任务      promises[num] = func(task).then(() =&gt; &#123;        // 这里的num是在 并发池 中位置的标识，这样可以更加方便的就行任务的替换        return num;      &#125;)    &#125;)  &#125;, Promise.resolve()).then(() =&gt; &#123;    // 这个任务是为了 在所有任务执行完之后添加一个回调方法，不然就会在最后一个任务进入并发池的时候就完成，而不是所有任务都执行完成    return Promise.all(promises)  &#125;)&#125;multiTask(urls, loadImg, 3).then(() =&gt; &#123;  console.log(&quot;都完事儿了！&quot;)&#125;)\n\n可以看到，代码主要是维护一个定长的数组来实现控制，数组的长度取决于规定的最大并发数。\n\n","tags":["JS"]},{"title":"写于2019的最后一个晚上","url":"/2019/12/%E5%86%99%E4%BA%8E2019%E7%9A%84%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E6%99%9A%E4%B8%8A/","content":"今天是2019年的最后一天，最后一个夜晚。我上次总结还是去年的年底，今年也不例外，需要对今年做一个总结，同时对2020做一个畅想。\n2019对于我来说真的是非常特殊的一年，这一年发生了很多的事情，而且偏偏又在最后的节点给了我一个措手不及。所以这一年，起码现在这个时间，让我有很多感想。\n2019年是我工作的第二个年头（2018年夏天毕业）。这是我作为职场人完整的一年，工作上，不像一开始一样手忙脚乱，慢慢的工作上的事情变的越来越熟练，自己也能承担起更多的、更复杂的事情，所以对个人的技术能力的提高也是很有效果的。之前我总被人说不会为人处事，很多事情做的不好，人不够圆滑，不够机灵。这一年针对这些问题我也努力做了很多的改进，学习变得更加的机灵。就像那句话说的，人在社会上总会有自己的一个外壳，有了这个外壳自己才会免于受到很多伤害，一开始的我们都是赤裸裸的面对，逐渐的我们都会有一个属于我们自己的外壳，当我们面对亲人朋友的时候才会脱去外壳。我觉得这句话说的挺有道理的，就像很多明星都有自己的“人设”，不一定是真实的自己，但是却能够帮助自己更好的在社会上游刃有余。\n下半年的时候为自己张罗了一个小的安身之所，举债上车。算是一件大事，不管未来的价格会怎样起码让自己有了一个归所，让自己在外漂泊的时候能想到那里有自己的一个避风港。这是期盼已久的一件事情了，为了自己和女朋友，终于完成了这件事情。\n如果2019只是发生这些的话，这会是一个很好的年，所有的事情都在朝着好的方向在发展，对于未来也有了更加强烈的期待。但是最后的时候却给了自己一个下马威，让我不得不面对这样一个困难。让我对于自身，对于职业规划甚至人生规划都有了很大的改变。这段时间想得很多，心情很复杂，有迷茫、有困苦、有不知所措、有痛苦徘徊。我需要真的冷静下来好好思考，坚定面对，我一定可以胜利！！\n不管这一年发生了什么，这都是很重要的一年，让我经历了很多，成长了很多，蜕变了很多，改变了我很多对于世界对于他人的看法。开心也好，悲伤也罢，这个夜晚总会过去，明天太阳升起的时候就是2020，时间不会停下脚步，所以不管发生了什么，都要一直向前！\n2020年，我希望自己在技术上能有一个大的提升，做一个披着外壳的社会人，但是要永远保持善良，永远充满希望。希望在工作中能更上一层楼，赚更多的钱（哈哈，我是个俗人）。希望父母身体健康，自己也健康。希望所有的事情都能有美满的结局！\n2020你好~\n","tags":["感悟"]},{"title":"基于Vue的弹框插件","url":"/2018/06/%E5%9F%BA%E4%BA%8EVue%E7%9A%84%E5%BC%B9%E6%A1%86%E6%8F%92%E4%BB%B6/","content":"早就萌生了发npm包的想法，之前一直认为这是个很高大上的事情，其实自己操作之后发现也比较简单，所以在这里记录一下自己的发包流程以及遇到的一些坑。\n\n好多文章讲的不细致，以至于走了很多的弯路\n\n我发布的是一个使用Vue开发的弹框组件\n工具介绍由于使用Vue开发，所以使用到的有 vue-cli 、 webpack-simple 。使用 webpack-simple 的原因是更加轻量，设置起来也更加容易，方便于发包，推荐大家使用，当然可以在自己的开发环境中先开发好插件，然后再复制到 webpack-simple 中。\n基本流程\n首先选择一个文件夹创建 webpack-simple 项目，使用命令。\n vue init webpack-simple xxx(your project name)\n 然后进入目录安装依赖\n cd xxx(your project name)npm install\n创建好之后在 src 目录下新建一个文件夹，来开发自己的插件，项目结构如图\n \n\n图中的 libs 就是创建的目录，来开发插件，为了方便整理，最好将所需要的文件都放在同一目录下。\n\n 在 libs 中开发自己的插件，并且可以在 main.js 中调用，来本地调试。\n\n插件开发过程。\n 插件想要能够在文件中被使用，必须要有一个 install 的函数，所以在 libs 目录下新建一个 index.js 文件，基本结构如下：\n const pulginName = &#123;    install () &#123;    &#125;&#125;export default pulginName\n\n 这里的 install 是必须的。以下是我的 index.js 内容:\n   import Vue from &#x27;vue&#x27;  import Toast from &#x27;./Toast.vue&#x27;  import Confirm from &#x27;./Confirm.vue&#x27;  const vdialog = &#123;  vm: null,  create (VueOpt, defaultOpt, opt) &#123;    opt = &#123;      ...defaultOpt,      ...opt    &#125;    let Dialogs = Vue.extend(VueOpt, opt)    this.vm = new Dialogs(&#123;el: document.createElement(&#x27;div&#x27;)&#125;)    Object.assign(this.vm, opt)    document.body.appendChild(this.vm.$el)    this.vm.$on(&#x27;close&#x27;, () =&gt; &#123;      this.close()    &#125;)  &#125;,  close () &#123;    document.body.removeChild(this.vm.$el)    this.vm.$destroy()    this.vm = null  &#125;,  install () &#123;    Vue.prototype.$toast = (opt = &#123;&#125;) =&gt; &#123;      let defaultOpt = &#123;        msg: &#x27;提示&#x27;,        type: &#x27;warnning&#x27;,        duration: 800      &#125;      this.create(Toast, defaultOpt, opt)    &#125;    Vue.prototype.$confirm = (opt = &#123;&#125;) =&gt; &#123;      let defaultOpt = &#123;        type: &#x27;&#x27;,        title: &#x27;标题&#x27;,        content: &#x27;内容...&#x27;,        confirmText: &#x27;确定&#x27;,        cancelText: &#x27;&#x27;,        confirm: () =&gt; &#123;          this.close()        &#125;,        cancel: () =&gt; &#123;          this.close()        &#125;      &#125;      this.create(Confirm, defaultOpt, opt)    &#125;    Vue.prototype.$close = () =&gt; &#123;      this.close()    &#125;  &#125;&#125;export default vdialog\n\n 可以看到我们添加了 $toast 、 $confirm 、 $close 三个全局函数到 Vue 上。引入了两个文件就是插件的主要内容，这里举例 Toast.vue 的内容:\n &lt;template&gt;  &lt;div class=&quot;vdialog&quot;&gt;    &lt;div class=&quot;mask&quot;&gt;&lt;/div&gt;    &lt;div class=&quot;area&quot; @click=&quot;closeDialog&quot;&gt;      &lt;i class=&quot;top-icon&quot; :class=&quot;getShowType&quot;&gt;&lt;/i&gt;      &lt;p&gt;&#123;&#123; msg &#125;&#125;&lt;/p&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  name: &#x27;vdialog&#x27;,  props: &#123;    msg: &#123;      type: String    &#125;,    type: &#123;      type: String    &#125;,    duration: &#123;      type: Number    &#125;  &#125;,  computed: &#123;    getShowType () &#123;      return `icon-$&#123;this.type&#125;`    &#125;,    getDuration () &#123;      return this.duration    &#125;  &#125;,  mounted () &#123;    setTimeout(() =&gt; &#123;      this.timeLine()    &#125;)  &#125;,  methods: &#123;    timeLine () &#123;      setTimeout(() =&gt; &#123;        this.closeDialog()      &#125;, this.getDuration)    &#125;,    closeDialog () &#123;      this.$emit(&#x27;close&#x27;)    &#125;  &#125;&#125;&lt;/script&gt;&lt;style lang=&quot;scss&quot; scoped&gt;// scss ...&lt;/style&gt;\n 在 main.js 中引入我们的插件，就可以使用了。\n import Vue from &#x27;vue&#x27;import App from &#x27;./App.vue&#x27;import vdialog from &#x27;./libs&#x27;Vue.use(vdialog)new Vue(&#123;  el: &#x27;#app&#x27;,  render: h =&gt; h(App)&#125;)\n 首先 import 然后 Vue.use() 来全局注册插件。\n\n打包前配置\n 打包的任务当然是交给 webpack-simple 来完成，找到文件 webpack.config.js 修改其中内容:\n var path = require(&#x27;path&#x27;)var webpack = require(&#x27;webpack&#x27;)module.exports = &#123;  entry: &#x27;./src/libs/index.js&#x27;,  // 将入口修改为自己插件的 index.js 文件位置，从 index.js 文件开始打包  // entry: &#x27;./src/main.js&#x27;,  // 最好将原来的配置注释起来，因为一会儿还要测试，再改回来  output: &#123;    path: path.resolve(__dirname, &#x27;./dist&#x27;),    publicPath: &#x27;/dist/&#x27;,    filename: &#x27;vue-toast-confirm.js&#x27;,  // 将 filename 改为自己插件的名字，当然是希望打包完是自己插件的名字啊    // filename: &#x27;build.js&#x27;,    library: &#x27;vue-toast-confirm&#x27;,  // 这一项是将来执行 import 的时候的名称 ，例如 import xxx from vue-toast-confirm    libraryTarget: &#x27;umd&#x27;,  // 构建方式，建议使用服务端和浏览器端都支持的 umd     umdNamedDefine: true   // 构建过程中对模块命名  &#125;,  // 将 vue 设置为外部依赖，不打包在自己的包里。并且对各种打包方式后的 Vue 依赖设置名称，否则会出现插件中 Vue.prototype 声明的全局函数找不到的情况。  externals: &#123;    vue: &#123;      root: &#x27;Vue&#x27;,      commonjs: &#x27;vue&#x27;,      commonjs2: &#x27;vue&#x27;,      amd: &#x27;vue&#x27;    &#125;  &#125;,  resolve: &#123;      extensions: [&#x27;&#x27;, &#x27;.js&#x27;, &#x27;.vue&#x27;]  &#125;,  // 其他的内容不变&#125;\n 配置好文件之后就可以执行 npm run build 来编译打包项目了，打包之后的文件在 dist 文件夹中，通常会有 .js 和 .js.map 两个文件，如果有其他文件的话也会引入。\n\n插件配置并发布\n 进入 dist 文件夹，执行 npm init 来创建 package.json 文件，过程中会需要输入包名等，按需输入即可。然后创建 README.md 来说明自己的插件（最好用英文，哈哈）。\n 一切准备妥当，接下来就是万众瞩目的时刻了，依然在 dist 目录下，执行 npm publish 来发布。 当然在这之前你需要有一个 npm 账号，并且验证了邮箱，否则不允许发包。在自己的电脑上要登陆 npm 账号，npm login 。如果不知道电脑上登陆的是哪个账号的话，执行 npm whoami 。\n\n\n记录自己的第一次发 npm 包的坎坷。\n","tags":["Vue"]},{"title":"基于角色的后台权限控制实现","url":"/2019/09/%E5%9F%BA%E4%BA%8E%E8%A7%92%E8%89%B2%E7%9A%84%E5%90%8E%E5%8F%B0%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6%E5%AE%9E%E7%8E%B0/","content":"对于后台的权限控制是非常重要的，每个人拥有不同的权限，每个人做的事情都不一样，这是非常重要的。用户只能看到他该看到的，只能修改他该修改的。这样才能做到安全的控制。\n1. 什么是权限控制对于后台的权限控制，大家用到最多的就是基于角色的权限控制。简单来说就是把给用户一个角色，这个角色拥有什么权限，用户就拥有什么权限。用户和角色是多对一的，也就是一个用户只能有一种角色，一个角色可以被很多用户拥有。\n这样就像用户和用户组一样，只要管理好角色的权限然后赋予用户都个角色就可以达到目的。\n2. 设计思想在前端，我觉得对于用户来说应该是所见即所得，也就是能看到的就都是有权限的，不存在明明在那但是不能点的按钮。所以就需要对于路由和按钮都要做控制。\n简单来说，根据用户的权限来过滤路由，最后只得到用户有权限的路由，在页面内，也要根据权限来隐藏部分内容（如用户只有读权限没有写权限的话，修改和添加按钮就不能展示）。\n3. 前端该怎么做首先是路由的问题，这里我们把路由分为三个部分：基础路由（直接就有的路由，如登陆）、普遍路由（需要后添加，但是不用权限验证的路由，如首页和个人中心）、权限路由（需要权限验证的路由）。\n一开始只有一个登陆的页面，登陆之后拿到用户拥有的权限之后就开始路由的过滤：\nfunction getRealRoute(userRoute) &#123;  let ins = routes;  for(let j = 0; j &lt; ins.length; j++) &#123;    let item = ins[j];    // 有子节点，遍历子节点    if(item.children &amp;&amp; item.children.length &gt; 0) &#123;      for(let i = 0; i &lt; item.children.length; i++) &#123;        // 如果子节点没有权限的话，就删掉        if(!Object.keys(userRoute).includes(item.children[i].name)) &#123;          ins[j].children.splice(i, 1);                    i--;        &#125;        else        &#123;          // 是否有写权限          if(userRoute[item.children[i].name].write) &#123;            ins[j].children[i].meta.write = true;          &#125;          else &#123;            ins[j].children[i].meta.write = false;          &#125;        &#125;      &#125;      // 如果所有子节点都没权限的话，父节点删掉      if(item.children &amp;&amp; item.children.length &lt; 1) &#123;        ins.splice(j, 1);        j--;      &#125;    &#125;    // 没有子节点，也没有权限的话，就删掉    else if(!Object.keys(userRoute).includes(item.name)) &#123;      ins.splice(j, 1);      j--;    &#125;  &#125;  // ins 就是过滤之后，用户有权限的路由  needToAdd = needToAdd.concat(ins);  needToAdd[0].children = [].concat(base, ins);  //   store.dispatch(&#x27;permission/saveRoutes&#x27;, needToAdd);  // 使用 router 对象的方法添加路由  router.addRoutes(needToAdd);  return [].concat(base, ins);&#125;\n\n这是简单的路由过滤，因为我们规定只能有一层子菜单，所以不需要用到深度遍历。这样我们就拿到了这个用户有权限的路由，然后在改变页面的时候使用 store 记录对于当前页面的具体权限（读、写）。\nrouter.beforeEach((to, from, next) =&gt; &#123;  if(to.name == &#x27;login&#x27;) &#123;    next();  &#125;  else if(store.state.permission.getToken) &#123;    if(to.meta) &#123;      // 记录用户对于当前页面的读写权限      store.dispatch(&#x27;permission/setPageWrite&#x27;, Boolean(to.meta.write));    &#125;    if(!store.state.permission.account) &#123;      store.dispatch(&#x27;permission/getInfo&#x27;).then(() =&gt; &#123;        next(&#123; ...to, replace: true &#125;)      &#125;)    &#125;    else &#123;      next();    &#125;  &#125;  else &#123;    next(&#123; path: &#x27;/login&#x27; &#125;)  &#125;&#125;)\n\n然后我们就可以对于当前的页面实现读写级别的控制。\ncomputed: &#123;  haswrite() &#123;    return this.$store.getters[&#x27;permission/getWrite&#x27;];  &#125;&#125;\n\n4. 后端该怎么做后端要做的其实就是两个事情：存储角色的权限、接口权限的验证。\n存储角色的权限只是将结果前端修改之后的一串 json 存储下来。权限验证的话我这里通过使用 php lumen 框架的中间件来实现：\nprivate function checkAuth() &#123;    // 获取需要权限验证的接口，以及接口需要的权限    $authList = $this-&gt;auth-&gt;getInterNeedCheck();    // 不在验证列表里的就不验证    if(!isset($authList[$this-&gt;nowAction])) &#123;      return true;    &#125;    // 这个接口需要什么权限    $needPower = $authList[$this-&gt;nowAction];    // 获取用户拥有的权限    session_start();    $have = isset($_SESSION[&#x27;admin&#x27;]) ? $_SESSION[&#x27;admin&#x27;]-&gt;route : null;    session_write_close();    if(!$have || !is_array($have) || count($have) &lt; 1) &#123;      return false;    &#125;    // 判断权限是否满足    foreach(array_keys($needPower) as $item) &#123;      $needSoon = $have[$item];      $readOrWrite = $needPower[$item];      if(empty($readOrWrite)) &#123;        return false;      &#125;      // 只要有这个路由权限，就一定有读权限      if($readOrWrite == &#x27;read&#x27;) &#123;        return true;        break;      &#125;      if(isset($needSoon[$readOrWrite]) &amp;&amp; $needSoon[$readOrWrite]) &#123;        return true;        break;      &#125;    &#125;    return false;  &#125;\n\n5. 怎么管理前面说了，对于每个角色维护一段 json。如图：\n\n以上是对于权限控制实现的总结，总的来说做的比较简陋，但是基本实现了对于 用户 - 角色 - 权限 的控制，也只是贴了部分代码。\n后台页面UI组件使用 Element 。挺好用哈哈\n","tags":["Vue","前端"]},{"title":"当GET请求遇到数组","url":"/2021/04/%E5%BD%93GET%E8%AF%B7%E6%B1%82%E9%81%87%E5%88%B0%E6%95%B0%E7%BB%84/","content":"前言 我们日常开发中，经常会遇到要在请求中携带数组的情况。但是由于encode，数据都会被转化为字符串传输。我们来探究这种情况下数组该如何转换，有哪些形式来转换。当然，不管哪种形式的传输，都需要服务器接口支持对应的格式。\n\n一般情况下不建议用 GET 传输数组，因为无法保证数组长度，可能会超出get长度限制。在确保小数据量的情况下，我们可以讨论。\n\n形式通常情况下，我们会把数组转换成别的形式，比如说转化成逗号分隔的字符串或者直接转化成 json 来传输。\narr = [1, 2, 3];// 转化成逗号分隔?arr=1,2,3// 转化成json?arr=[1,2,3]\n\n这两种形式是比较常用的转化形式，通过服务器同学的解码，可以重新得到数组。但是除了这两种形式，还有哪些形式吗？\n通过学习，我们了解到，常常被使用的还有如下几种形式：\narr = [1, 2, 3];// 带 []?arr[]=1&amp;arr[]=2&amp;arr[]=3// 带 []，且有下标的?arr[0]=1&amp;arr[1]=2&amp;arr[2]=3// 重复出现?arr=1&amp;arr=2&amp;arr=3\n\n实现这时候是不是有个疑惑，那我们每次传参之前都得手动转一遍，岂不是很麻烦？\n其实 qs 就自带了这个功能。\nqs.stringify(&#123; a: [&#x27;b&#x27;, &#x27;c&#x27;] &#125;, &#123; arrayFormat: &#x27;indices&#x27; &#125;)// &#x27;a[0]=b&amp;a[1]=c&#x27;qs.stringify(&#123; a: [&#x27;b&#x27;, &#x27;c&#x27;] &#125;, &#123; arrayFormat: &#x27;brackets&#x27; &#125;)// &#x27;a[]=b&amp;a[]=c&#x27;qs.stringify(&#123; a: [&#x27;b&#x27;, &#x27;c&#x27;] &#125;, &#123; arrayFormat: &#x27;repeat&#x27; &#125;)// &#x27;a=b&amp;a=c&#x27;qs.stringify(&#123; a: [&#x27;b&#x27;, &#x27;c&#x27;] &#125;, &#123; arrayFormat: &#x27;comma&#x27; &#125;)// &#x27;a=b,c&#x27;\n\n我们也可以自己来实现一遍\nfunction formatArrayFunc(key, array, format) &#123;  switch(format) &#123;    case &#x27;brackets&#x27;:      return bracketsArray(key, array);    case &#x27;indices&#x27;:      return indicesArray(key, array);    case &#x27;repeat&#x27;:      return repeatArray(key, array);    case &#x27;comma&#x27;:      return commaArray(key, array);    default:      return `$&#123;key&#125;=$&#123;JSON.stringify(array)&#125;`;  &#125;&#125;function stringifyParams(params, formatArray = &#x27;comma&#x27;) &#123;  let str = [];  Object.keys(params).forEach(key =&gt; &#123;    if(Array.isArray(params[key])) &#123;      str.push(formatArrayFunc(key, params[key], formatArray));    &#125;    else &#123;      str.push(`$&#123;String(key)&#125;=$&#123;String(params[key])&#125;`);    &#125;  &#125;);  return &#x27;?&#x27; + str.join(&#x27;&amp;&#x27;);&#125;function bracketsArray(key, array) &#123;  return array.map(item =&gt; &#123;    return `$&#123;key&#125;[]=$&#123;item&#125;`  &#125;).join(&#x27;&amp;&#x27;);&#125;function indicesArray(key, array) &#123;  return array.map((item, index) =&gt; &#123;    return `$&#123;key&#125;[$&#123;index&#125;]=$&#123;item&#125;`  &#125;).join(&#x27;&amp;&#x27;);&#125;function repeatArray(key, array) &#123;  return array.map(item =&gt; &#123;    return `$&#123;key&#125;=$&#123;item&#125;`  &#125;).join(&#x27;&amp;&#x27;);&#125;function commaArray(key, array) &#123;  return `$&#123;key&#125;=$&#123;array.join(&#x27;,&#x27;)&#125;`;&#125;const params = &#123;  name: &#x27;lzd&#x27;,  list: [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;],  isvip: true&#125;console.log(stringifyParams(params, &#x27;indices&#x27;));// ?name=lzd&amp;list[0]=a&amp;list[1]=b&amp;list[2]=c&amp;isvip=trueconsole.log(stringifyParams(params, &#x27;brackets&#x27;));// ?name=lzd&amp;list[]=a&amp;list[]=b&amp;list[]=c&amp;isvip=trueconsole.log(stringifyParams(params, &#x27;repeat&#x27;));// ?name=lzd&amp;list=a&amp;list=b&amp;list=c&amp;isvip=trueconsole.log(stringifyParams(params, &#x27;comma&#x27;));// ?name=lzd&amp;list=a,b,c&amp;isvip=true\n\n接收以上我们讨论的数组的转化形式，都需要服务器做相应的处理，可以事先就约定好形式。有的形式需要接口中处理，如逗号分隔形式，json形式，有的形式个别框架会自动转换，如 brackets、indices。\n我们可以实现一个接收各种形式数组转化，并且转化成真数组的方法。\n\n我们主要针对 indices、brackets、repeat 三种形式，因为这个明确是数组形式。但是 comma 和 逗号分隔，其本来形式并不一定是数组。所以需要针对特点场景来做具体处理，这里不做处理\n\nfunction parseParam(url) &#123;  const paramsUri = /.*\\?(.*)$/.exec(url)[1];  // 没匹配到直接返回空对象  if(!paramsUri) return &#123;&#125;;  const keyValues = paramsUri.split(&#x27;&amp;&#x27;);  const result = &#123;&#125;  keyValues.forEach(item =&gt; &#123;    // 检查是否带有的等号    if(/=/.test(item)) &#123;      const split = item.split(&#x27;=&#x27;);      // 是否带有 []，带的话，肯定是数组      if(/\\[(\\d?)\\]/.test(split[0])) &#123;        const array = (/(.*)\\[(\\d?)\\]/.exec(split[0]));        // 检查是 list[]=1&amp;list[]=2 类型 还是 list[1]=1&amp;list[2]=2        if(array[2] === &#x27;&#x27;) &#123;                    if(!result[array[1]]) &#123;            result[array[1]] = [];          &#125;          result[array[1]].push(split[1])        &#125;        else &#123;          if(!result[array[1]]) &#123;            result[array[1]] = [];          &#125;          result[array[1]][array[2]] = split[1]        &#125;      &#125;      // 没有 []，不一定不是数组，可能是 repeat 形式的      else &#123;        if(result[split[0]]) &#123;          if(Array.isArray(result[split[0]])) &#123;            result[split[0]].push(split[1])          &#125;          else &#123;            result[split[0]] = [result[split[0]], split[1]]          &#125;        &#125;        else &#123;          result[split[0]] = split[1]        &#125;      &#125;    &#125;    else &#123;      // 没带等号的，默认值为 true      result[item] = true;    &#125;  &#125;)  return result;&#125;const url = &quot;baidu.com?testname=yiqihaochidian&amp;list[0]=lzd&amp;list[1]=la&amp;list[2]=lml&amp;qs[]=1&amp;qs[]=2&amp;isvip&amp;business=changba&amp;user=lzd&amp;user=liao&amp;user=ys&quot;;console.log(parseParam(url));// &#123;//   testname: &#x27;yiqihaochidian&#x27;,//   list: [ &#x27;lzd&#x27;, &#x27;la&#x27;, &#x27;lml&#x27; ],//   qs: [ &#x27;1&#x27;, &#x27;2&#x27; ],//   isvip: true,//   business: &#x27;changba&#x27;,//   user: [ &#x27;lzd&#x27;, &#x27;liao&#x27;, &#x27;ys&#x27; ]// &#125;\n\n","tags":["前端","HTTP"]},{"title":"重新了解防抖和节流","url":"/2019/01/%E9%87%8D%E6%96%B0%E4%BA%86%E8%A7%A3%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81/","content":"防抖和节流是平时经常用到的基础的方法，在前端开发时，对于很多场景都需要做相应的防抖或者节流处理，否则会造成性能的浪费或者影响用户体验，比如说常见到的 resize 和 scroll 事件。\n但是很多同学经常把防抖和节流搞混，防抖当成节流，节流认为是防抖。所以我们重新理解学习一下防抖和节流的知识！\n\n浏览器中某些计算和处理要比其他的昂贵很多。例如，DOM 操作比起非 DOM 操作需要更多的内存和 CPU 时间。连续尝试进行过多的 DOM 相关操作可能会导致浏览器挂起，有时候甚至会崩溃。尤其在 IE 中使用 onresize 事件处理程序的时候容易发生，当调整浏览器大小的时候，该时间会连续触发。在 onresize 事件处理程序内部如果尝试进行 DOM 操作，其高频率的更改可能会让浏览器崩溃。为了绕开这个问题。你可以使用定时器对该函数进行节流。  \n\n\n函数节流背后的思想是指，在某些代码不可以在没有间断的情况下连续重复执行。第一次调用函数，创建一个定时器，在指定的时间间隔之后运行代码。当第二次调用该函数的时候，他会清除第一次的定时器并设置另一个。…… 目的是只有在执行函数的请求停止了一段时间之后才执行。\n\n以上是红宝石书对于函数节流的描述。从中可以理解到，对于连续重复执行的代码，限制其执行。比如说有连续十个请求，间隔一秒钟连续发起请求。如果我们设置的节流时间是两秒的话，只有在最后一个请求后两秒才会真正的执行这个请求。\n这种情况经常应用在处理用户输入时，如果要根据用户输入的内容发起请求，不加限制的话，用户每次修改（输入或者删除）都会触发请求，但是用户没有完成输入的话，前面的请求都是浪费的，没必要的。所以我们限制用户输入完成一段时间之后才发起请求，代码如：\nlet input = document.getElementById(&#x27;input&#x27;);let example = debounce(request, 300);input.onkeyup = e =&gt; &#123;  example(e.target.value); &#125;function debounce(func, delay) &#123;  let timer;  return args =&gt; &#123;    clearTimeout(timer);    timer = setTimeout(() =&gt; &#123;      func(args);    &#125;, delay);  &#125;&#125;function request(val) &#123;  console.log(&#x27;request: &#x27; + val);&#125;\n\n但是！\n日常使用中，我们认为的节流并不是这样的，这种函数我们一般叫做防抖，顾名思义就是防止不停抖动，等平静下来了不抖了再去处理。那节流是什么啥样子呢？\nlet example = throttle(doSomeThing, 300);window.onresize = () =&gt; &#123;  example();&#125;function throttle(func, delay) &#123;  let timer;  return args =&gt; &#123;    if(timer) return;    func(args);        timer = setTimeout(() =&gt; &#123;      clearTimeout(timer);      timer = null;    &#125;, delay);  &#125;&#125;function doSomeThing() &#123;  console.log(&#x27;do some thing...&#x27;);&#125;\n\n这是一个简单的节流函数，节流的意思是某时间段内函数只能执行一次，如上述代码，当我们不停拖动窗口大小的时候，onresize 是不停触发的，但是通过我们限制，允许他最多每 300ms 执行一次，这样可以大大的减少性能的浪费，提高我们程序的性能。\n以上都是简单的防抖和节流的用法，对于更复杂的场景或有更高级的写法，我们就不去探究了。这次我们主要是弄清楚防抖和节流的区别，了解各自的应用场景。\n","tags":["JS"]},{"title":"一名前端的基础位运算修养","url":"/2021/01/%E4%B8%80%E5%90%8D%E5%89%8D%E7%AB%AF%E7%9A%84%E5%9F%BA%E7%A1%80%E4%BD%8D%E8%BF%90%E7%AE%97%E4%BF%AE%E5%85%BB/","content":"\n一名前端的基础修养系列 —- 位运算\n\n1. 进制转换\n\njs 自带的进制转换api： toString()\n2. 十进制数的原码、反码、补码\n进为什么会有原码、反码、补码？\n是为了解决用二进制表示复数，将人习惯使用的符号转换为机器可以处理的形式。\n那么，什么事原码、反码、补码？\n\n2. 十进制数的原码、反码、补码\n进为什么会有原码、反码、补码？\n是为了解决用二进制表示复数，将人习惯使用的符号转换为机器可以处理的形式。\n那么，什么事原码、反码、补码？\n\n2.1 概念2.1.1 原码原码就是符号位加上真值的绝对值, 即用第一位表示符号, 其余位表示值. 比如如果是 8 位二进制:\n十进制 -&gt; 原码1  -&gt; 0000 0001-1 -&gt; 1000 0001\n\n正负数的原码有区别，那 0 呢？\n十进制 -&gt; 原码+0 -&gt; 0000 0000-0 -&gt; 1000 0000\n\n2.1.2 反码\n正数的反码与其原码相同\n负数除了符号位，其他位置均取反\n\n十进制 -&gt; 原码 -&gt; 反码1  -&gt; 0000 0001 -&gt; 0000 0001-1 -&gt; 1000 0001 -&gt; 1111 11100?+0 -&gt; 0000 0000 -&gt; 0000 0000-0 -&gt; 1000 0000 -&gt; 1111 1111\n\n2.1.3 补码\n正数的补码就是其本身\n负数的补码是其反码 + 1\n\n十进制 -&gt; 原码 -&gt; 反码 -&gt; 补码1  -&gt; 0000 0001 -&gt; 0000 0001 -&gt; 0000 0001-1 -&gt; 1000 0001 -&gt; 1111 1110 -&gt; 1111 11110?+0 -&gt; 0000 0000 -&gt; 0000 0000 -&gt; 0000 0000-0 -&gt; 1000 0000 -&gt; 1111 1111 -&gt; 0000 0000\n\n\n 补码没有正0与负0之分\n\n2.2 练习已知一个数字的补码是 11101101 求其十进制数?\n解：补码: 1110 1101    (首位是符号位，是 1，说明是负数)反码: 1110 1100    (补码 -1 是反码)原码: 1001 0011    (反码除了符号位均取反，是原码)十进制: -19\n\n3. 位运算符\n\n\n表达式\n符号\n解释\n\n\n\na &amp; b\n&amp;\n位与运算，两者皆1则为1\n\n\na | b\n|\n位或运算，有一个1则为1\n\n\na ^ b\n^\n异或运算，不同则为1，否则为0\n\n\n~a\n~\n取反运算，0变成1，1变成0\n\n\na &lt;&lt; b\n&lt;&lt;\n左移，将 a 左移 b 位（b&lt;32），右边用 0 填充\n\n\na &gt;&gt; b\n&gt;&gt;\n有符号右移，将 a 右移 b 位（b&lt;32），右边超出的位丢弃，左边部分按照符号位补齐（正数补0，负数补1）\n\n\na &gt;&gt;&gt; b\n&gt;&gt;&gt;\n无符号右移，将 a 右移 b 位（b&lt;32），右边超出的丢弃，左边补0\n\n\n做一下练习：\n\nJavaScript 将数字存储为 64 位浮点数，但所有按位运算都以 32 位二进制数执行。\n在执行位运算之前，JavaScript 将数字转换为 32 位有符号整数。\n执行按位操作后，结果将转换回 64 位 JavaScript 数。\n以下操作，为了简化表示，不补齐 32 位。\n\n十进制：14 &amp; 19运算：      0000 1110      0001 0011      ---------  &amp;      0000 0010结果： 2\n\n十进制：14 | 19运算：      0000 1110      0001 0011      ---------  |      0001 1111结果： 31\n\n十进制：14 ^ 19运算：      0000 1110      0001 0011      ---------  ^      0001 1101结果： 29负数？十进制：-14 ^ 19运算：      1000 1110 (原码)\t\t\t---------      1111 0001 (反码)      ---------        1111 0010 (补码)      0001 0011      ---------  ^      1110 0001 (补码)      ---------      1110 0000 (反码)      ---------      1001 1111 (原码)结果： -31\n\n十进制：~ 14运算：      0000 1110      ---------  ~      1111 0001 (补码)      ---------      1111 0000 (反码)      ---------      1000 1111 (原码)结果： -15负数？十进制：~ -14运算：      1000 1110 (原码)\t\t\t---------      1111 0001 (反码)      ---------        1111 0010 (补码)      ---------  ~      0000 1101 (原码)结果： 13这里有一个规律：~a &#x3D; -(a + 1)why ? (因为补码和反码转换的时候，+1 或则会 -1 造成的)\n\n十进制：14 &lt;&lt; 3运算：      0000 0000 0000 1110      ------------------- &lt;&lt; 3      0000 0000 0111 0000结果： 112 (相当于 14 * 2 * 2 * 2)负数的移动？十进制：-14 &lt;&lt; 3运算：      1000 0000 0000 1110 (原码)      -------------------      1111 1111 1111 0001 (反码)      -------------------      1111 1111 1111 0010 (补码)      ------------------- &lt;&lt; 3      1111 1111 1001 0000 (补码)      -------------------      1111 1111 1000 1111 (反码)      -------------------      1000 0000 0111 0000 (原码)结果： -112\n\n十进制：14 &gt;&gt; 3运算：      0000 0000 0000 1110      ------------------- &gt;&gt; 3      0000 0000 0000 0001结果： 1 (相当于 14 除了 3 次 2，每次抛弃小数点后的)负数的移动？十进制：-14 &gt;&gt; 3运算：      1000 0000 0000 1110 (原码)      -------------------      1111 1111 1111 0001 (反码)      -------------------      1111 1111 1111 0010 (补码)      ------------------- &gt;&gt; 3      1111 1111 1111 1110 (补码)      -------------------      1111 1111 1111 1101 (反码)      -------------------\t\t  1000 0000 0000 0010 (原码)      结果： -2\n\n十进制：14 &gt;&gt;&gt; 3运算：      0000 0000 0000 1110      ------------------- &gt;&gt; 3      0000 0000 0000 0001结果： 1 (正数和有符号右移 &gt;&gt; 没有区别)负数的移动？十进制：-14 &gt;&gt; 3运算：      10000000 00000000 00000000 00001110 (原码)      ---------------------------------------      11111111 11111111 11111111 11110001 (反码)      ---------------------------------------      11111111 11111111 11111111 11110010 (补码)      --------------------------------------- &gt;&gt; 3      00011111 11111111 11111111 11111110 (原码)      结果： 536870910因为这里设计到二进制最左边，所以以全貌 32 位来展示。\n\n\n\n4. 实际应用4.1 颜色 RGB 和 十六进制 的互相转换我们注意到，rgb 的每一位数的范围都是 0 ～ 255。相当于  0 ～ 2^8 - 1，转换成二进制，刚好可以用8位表示完整。00000000 ～ 11111111，用 16 进制就是 00 ～ ff。\n4.1.1 RGB -&gt; 16进制给定一个用 RGB 格式表示的颜色 rgb(213, 87, 70)。\n首先，拆分一下，拿出来三个数字2138770然后，转化成二进制213 -&gt; 00000000 00000000 00000000 1101010187  -&gt; 00000000 00000000 00000000 0101011170  -&gt; 00000000 00000000 00000000 01000110我们如果想把这三个数变成一个数，直接转换为 16 进制。需要怎么操作呢？（位移）213 -&gt; 00000000 00000000 00000000 1101010187  -&gt; 00000000 00000000 00000000 0101011170  -&gt; 00000000 00000000 00000000 01000110213(?) -&gt; 00000000 11010101 00000000 0000000087(?)  -&gt; 00000000 00000000 01010111 0000000070(?)  -&gt; 00000000 00000000 00000000 01000110然后呢？这咋还是三个数，说好的一个呢？别急 （位或运算）213(?) -&gt; 00000000 11010101 00000000 0000000087(?)  -&gt; 00000000 00000000 01010111 0000000070(?)  -&gt; 00000000 00000000 00000000 01000110\t\t\t\t\t----------------------------------- |??        00000000 11010101 01010111 01000110                         d5       57       46                         \t\t\t\t\t\t\t#d55746\n\n把上面的过程转化成代码：\nconst rgbColor = &#x27;rgb(213, 87, 70)&#x27;;function rgbToHex(str) &#123;  const res = str.match(/^rgb\\((\\d&#123;1,3&#125;),\\s?(\\d&#123;1,3&#125;),\\s?(\\d&#123;1,3&#125;)\\)$/);  if(!res) return &#x27;invalid&#x27;;  const [ , red, green, blue] = res;  return &#x27;#&#x27; + (red &lt;&lt; 16 | green &lt;&lt; 8 | blue).toString(16);&#125;console.log(rgbToHex(rgbColor));  // #d55746\n\n反过来就是：\n拿到一个 16 进制颜色： #d55746；先转换成 2 进制#d55746 -&gt; 00000000 11010101 01010111 01000110接下来怎么分解成三个数呢？我们一个一个取，先取得 red#d55746 -&gt; 00000000 11010101 01010111 01000110           ----------------------------------- &gt;&gt; 16           00000000 00000000 00000000 11010101           \t\t\t\t\t\t\t\t\t\t\t\t\t\t    0xd5 -&gt; 213           挪动之后就只剩下了我们想要的值，下一个#d55746 -&gt; 00000000 11010101 01010111 01000110           ----------------------------------- &gt;&gt; 8           00000000 00000000 11010101 01010111           这下犯了难，不是我们想要的，那咋办呢，只想要后面部分的。（与运算）           00000000 00000000 11010101 01010111           00000000 00000000 00000000 11111111           ----------------------------------- &amp;           00000000 00000000 00000000 01010111                                          0x57 -&gt; 87           同理，拿到最后一个           00000000 11010101 01010111 01000110           00000000 00000000 00000000 11111111           ----------------------------------- &amp;           00000000 00000000 00000000 01000110                                          0x46 -&gt; 70                         \t\t\t\t\t\t\t\n\n同代码表示：\nconst hexColor = &#x27;#254&#x27;;function hexToRgb(str) &#123;  const res = str.match(/^#([0-9a-f]&#123;3&#125;|[0-9a-f]&#123;6&#125;)$/);  if(!res) return &#x27;invalid&#x27;;    let hex = res[1];  if(String(hex).length == 3) &#123;    hex = String(hex).split(&#x27;&#x27;).map(char =&gt; `$&#123;char&#125;$&#123;char&#125;`).join(&#x27;&#x27;);  &#125;  hex = Number(&#x27;0x&#x27; + hex)  return `rgb($&#123;hex &gt;&gt; 16 &amp; 0xff&#125;, $&#123;hex &gt;&gt; 8 &amp; 0xff&#125;, $&#123;hex &amp; 0xff&#125;)`;&#125;console.log(hexToRgb(hexColor));  // rgb(34, 85, 68)\n\n4.2 存储一个用户对应多个标签的问题。比如有100个标签，每个用户都可能有其中的任意个。这个用户和标签的对应关系怎么存储？假如往数据库里存？\n逗号分隔？不优雅！（虽然我们很多代码都是这样做的！）\n这种情况，按位存储是比较理想的方案，怎么做呢？\nconst tagList = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;];const userTags = [&#x27;b&#x27;, &#x27;e&#x27;];\n\n我们先假设给每个标签一个标记值\na -&gt;  1 -&gt; 00000001b -&gt;  2 -&gt; 00000010c -&gt;  4 -&gt; 00000100d -&gt;  8 -&gt; 00001000e -&gt; 16 -&gt; 00010000怎么存储呢？看起来没个标签对应一个二进制位，1 代表有这个标签，0 代表没有，所以我们吧他们集合起来不就可以了b -&gt;  2 -&gt; 00000010e -&gt; 16 -&gt; 00010000           -------- |           00010010 -&gt; 18 &#x3D; 16 + 2\n\n转化成代码，\nconst tagList = [&#x27;aa&#x27;, &#x27;bb&#x27;, &#x27;cc&#x27;, &#x27;dd&#x27;, &#x27;ee&#x27;, &#x27;ff&#x27;, &#x27;gg&#x27;, &#x27;hh&#x27;, &#x27;ii&#x27;, &#x27;jj&#x27;, &#x27;kk&#x27;];const inputTags = [&#x27;bb&#x27;, &#x27;ii&#x27;, &#x27;kk&#x27;];const saveTags = tags =&gt; tags.reduce((total, item) =&gt; total | (1 &lt;&lt; tagList.indexOf(item)), 0);const encodeRes = saveTags(inputTags);console.log(encodeRes);   // 1282\n\n现在存起来了，那取出来怎么再对应回去呢？\nconst tagList = [&#x27;aa&#x27;, &#x27;bb&#x27;, &#x27;cc&#x27;, &#x27;dd&#x27;, &#x27;ee&#x27;, &#x27;ff&#x27;, &#x27;gg&#x27;, &#x27;hh&#x27;, &#x27;ii&#x27;, &#x27;jj&#x27;, &#x27;kk&#x27;];const inputTags = [&#x27;bb&#x27;, &#x27;ii&#x27;, &#x27;kk&#x27;];const saveTags = tags =&gt; tags.reduce((total, item) =&gt; total | (1 &lt;&lt; tagList.indexOf(item)), 0);const encodeRes = saveTags(inputTags);console.log(encodeRes);   // 1282 const getTags = num =&gt; &#123;  let index = 0, res = [];  while(num &amp;&amp; index &lt; tagList.length) &#123;    if(num &amp; 1) &#123;      res.push(tagList[index]);    &#125;    num = num &gt;&gt; 1;    index++;  &#125;  return res;&#125;const decodeRes = getTags(encodeRes);console.log(decodeRes);   // [ &#x27;bb&#x27;, &#x27;ii&#x27;, &#x27;kk&#x27; ]\n\n用上面的例子，做个演示\na -&gt;  1 -&gt; 00000001b -&gt;  2 -&gt; 00000010c -&gt;  4 -&gt; 00000100d -&gt;  8 -&gt; 00001000e -&gt; 16 -&gt; 00010000我们有 18，18 -&gt; 0001 0010      index &#x3D; 0    0001 0010      &amp;1 &#x3D; 0   (说明没有 a)    []             --------- &gt;&gt; 1index &#x3D; 1    0000 1001      &amp;1 &#x3D; 1   (说明有 b)     [b]             --------- &gt;&gt; 1index &#x3D; 2    0000 0100      &amp;1 &#x3D; 0   (说明没有 c)   [b]             --------- &gt;&gt; 1index &#x3D; 3    0000 0010      &amp;1 &#x3D; 0   (说明没有 d)   [b]             --------- &gt;&gt; 1index &#x3D; 4    0000 0001      &amp;1 &#x3D; 1   (说明有 e)     [b, e]             --------- &gt;&gt; 1             0000 0000                 (end)\n\n\n\n5. 奇技淫巧\n找了几个 leetcode 上的算法题\n\n5.1 给定一个（正）整数，判断它是否是 2 的幂次方。解题思路？\n一直除 2 看是否可以等于 1？\nfunction isFun(num) &#123;  let res = false;  while(num &gt; 0) &#123;    if(num % 1 !== 0) break;    if(num === 1) &#123;      res = true;      break;    &#125;    num /= 2;  &#125;  return res;&#125;console.log(isFun(128)); // trueconsole.log(isFun(134)); // false\n\n可以实现功能，但是bigger不高啊！试一试用位运算来实现。我们可以先看看这些数都有哪些特点。\n\n\n\n1\n2\n4\n8\n16\n32\n…\n\n\n\n1\n10\n100\n1000\n10000\n100000\n…\n\n\n用二进制表示，只有第一位是1其余全是0。所以我们可以用这个特征来进行判断。\nfunction isFun(num) &#123;  return /^1(0)*$/.test(num.toString(2))&#125;console.log(isFun(128)); // trueconsole.log(isFun(134)); // false\n\n有没有更好的办法？更优雅？\nfunction isFun(num) &#123;  return !(num &amp; num - 1);&#125;console.log(isFun(128)); // trueconsole.log(isFun(134)); // false\n\n原理？\n128       -&gt; 1000 0000(128 - 1) -&gt; 0111 1111             --------- &amp;\t\t\t\t\t\t 0000 0000 -&gt; 0\t\t\t\t\t\t 134       -&gt; 1000 0110(134 - 1) -&gt; 1000 0101             --------- &amp;             1000 0100 -&gt; 132\n\n\n\n5.2 进阶！判断一个正整数是否是 4 的幂次方首先，满足是 4 的幂次方的数，一定也是 2 的幂次方数。如 上一题的表格所示。除此之外，他们也有自己的特征\n1  -&gt; 000000014  -&gt; 0000010016 -&gt; 0001000064 -&gt; 01000000\n\n可以看到，他的 1 是间隔出现的，从后往前数，都在奇数位置。\n所以根据这个特征，可以在满足是 2 进制数的基础上，做一次判断，就可以达到我们想要的效果。但是怎么做呢？\n可以扩展一下我们上面的正则方法，因为规律是 1 后面有 0 个或者偶数个0，\nfunction isFun(num) &#123;  const res = num.toString(2)  return /^1(00)*$/.test(res)&#125;console.log(isFun(64)); // trueconsole.log(isFun(128)); // false\n\n同样不够优雅，用位运算的方法是这样写\nfunction isFun(num) &#123;  if(num &amp; num - 1) return false;  return (num &amp; 0x55555555) === num;&#125;console.log(isFun(64));  // trueconsole.log(isFun(128)); // false\n\n0x55555555 是个什么玩意？？（黑人问号脸）\n0x55555555 -&gt; 01010101 01010101 01010101 01010101\n\n转换成二进制，是一个 0 和 1 间隔的，奇数为是 1 的串。为什么是这么个玩意呢？\n0x55555555 -&gt; 01010101 01010101 01010101 01010101256        -&gt; 00000000 00000000 00000001 00000000              ----------------------------------- &amp;              00000000 00000000 00000001 00000000 -&gt; 256              0x55555555 -&gt; 01010101 01010101 01010101 01010101128        -&gt; 00000000 00000000 00000000 10000000              ----------------------------------- &amp;              00000000 00000000 00000000 00000000 -&gt; 0              \n\n那，有没有什么其他的方法呢？\nfunction isFun(num) &#123;  return /^1(0)*$/.test(num.toString(4))&#125;console.log(isFun(256)); // trueconsole.log(isFun(128)); // falseconsole.log(isFun(134)); // false\n\n我们把这个数转化成 4 进制\n十进制 -&gt; 四进制256 -&gt; 0001 0000128 -&gt; 0000 2000137 -&gt; 0000 2021\n\n也是，满足 4 的幂次方数的，转化成 4 进制，同样是 1 开头，后面全是 0 （或者没有 0）。\n所以扩展一下，一个 x 的幂次方，转化成 x 进制。都是 1 开头后面全是 0 （或者没有 0）。\n扩展一下方法\n/** params* num 要验证的数* a 要满足的幂次方*/function isFun(num, a) &#123;  return /^1(0)*$/.test(num.toString(a))&#125;console.log(isFun(128, 2));  // trueconsole.log(isFun(81, 9));   // trueconsole.log(isFun(169, 13)); // true\n\n","tags":["前端修养","分享会","位运算"]}]